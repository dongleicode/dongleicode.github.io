import{_ as e,c as s,o as a,d as t}from"./app.ec983c26.js";const F=JSON.parse('{"title":"vue2 与 vue3的核心方法不同：","description":"","frontmatter":{},"headers":[{"level":2,"title":"defineProperty和proxy的异同","slug":"defineproperty和proxy的异同","link":"#defineproperty和proxy的异同","children":[{"level":3,"title":"区别一：监听方式","slug":"区别一-监听方式","link":"#区别一-监听方式","children":[]},{"level":3,"title":"区别二：对象新增属性","slug":"区别二-对象新增属性","link":"#区别二-对象新增属性","children":[]},{"level":3,"title":"区别三：对象删除属性","slug":"区别三-对象删除属性","link":"#区别三-对象删除属性","children":[]},{"level":3,"title":"区别四：数组监听","slug":"区别四-数组监听","link":"#区别四-数组监听","children":[]},{"level":3,"title":"问题：数组的 push、pop、shift、unshift、splice、sort，reverse是无法触发 set 方法的？","slug":"问题-数组的-push、pop、shift、unshift、splice、sort-reverse是无法触发-set-方法的","link":"#问题-数组的-push、pop、shift、unshift、splice、sort-reverse是无法触发-set-方法的","children":[]},{"level":3,"title":"解决方法：Vue能对对数组的这些原生方法进行监听，是因为 Vue 源码对数组的这些方法进行了重载：","slug":"解决方法-vue能对对数组的这些原生方法进行监听-是因为-vue-源码对数组的这些方法进行了重载","link":"#解决方法-vue能对对数组的这些原生方法进行监听-是因为-vue-源码对数组的这些方法进行了重载","children":[]},{"level":3,"title":"区别五：性能上","slug":"区别五-性能上","link":"#区别五-性能上","children":[]},{"level":3,"title":"相同点：不支持深层嵌套","slug":"相同点-不支持深层嵌套","link":"#相同点-不支持深层嵌套","children":[]}]},{"level":2,"title":"总结：proxy和defineProperty对比","slug":"总结-proxy和defineproperty对比","link":"#总结-proxy和defineproperty对比","children":[]},{"level":2,"title":"备注：","slug":"备注","link":"#备注","children":[]}],"relativePath":"vue/core.md"}'),l={name:"vue/core.md"},n=t(`<h1 id="vue2-与-vue3的核心方法不同" tabindex="-1">vue2 与 vue3的核心方法不同： <a class="header-anchor" href="#vue2-与-vue3的核心方法不同" aria-hidden="true">#</a></h1><hr><ul><li><a href="#vue2-%E4%B8%8E-vue3%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E4%B8%8D%E5%90%8C">vue2 与 vue3的核心方法不同：</a><ul><li><a href="#defineproperty%E5%92%8Cproxy%E7%9A%84%E5%BC%82%E5%90%8C">defineProperty和proxy的异同</a><ul><li><a href="#%E5%8C%BA%E5%88%AB%E4%B8%80%E7%9B%91%E5%90%AC%E6%96%B9%E5%BC%8F">区别一：监听方式</a></li><li><a href="#%E5%8C%BA%E5%88%AB%E4%BA%8C%E5%AF%B9%E8%B1%A1%E6%96%B0%E5%A2%9E%E5%B1%9E%E6%80%A7">区别二：对象新增属性</a></li><li><a href="#%E5%8C%BA%E5%88%AB%E4%B8%89%E5%AF%B9%E8%B1%A1%E5%88%A0%E9%99%A4%E5%B1%9E%E6%80%A7">区别三：对象删除属性</a></li><li><a href="#%E5%8C%BA%E5%88%AB%E5%9B%9B%E6%95%B0%E7%BB%84%E7%9B%91%E5%90%AC">区别四：数组监听</a></li><li><a href="#%E9%97%AE%E9%A2%98%E6%95%B0%E7%BB%84%E7%9A%84-pushpopshiftunshiftsplicesortreverse%E6%98%AF%E6%97%A0%E6%B3%95%E8%A7%A6%E5%8F%91-set-%E6%96%B9%E6%B3%95%E7%9A%84">问题：数组的 push、pop、shift、unshift、splice、sort，reverse是无法触发 set 方法的？</a></li><li><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95vue%E8%83%BD%E5%AF%B9%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E8%BF%99%E4%BA%9B%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E7%9B%91%E5%90%AC%E6%98%AF%E5%9B%A0%E4%B8%BA-vue-%E6%BA%90%E7%A0%81%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E8%BF%99%E4%BA%9B%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E4%BA%86%E9%87%8D%E8%BD%BD">解决方法：Vue能对对数组的这些原生方法进行监听，是因为 Vue 源码对数组的这些方法进行了重载：</a></li><li><a href="#%E5%8C%BA%E5%88%AB%E4%BA%94%E6%80%A7%E8%83%BD%E4%B8%8A">区别五：性能上</a></li><li><a href="#%E7%9B%B8%E5%90%8C%E7%82%B9%E4%B8%8D%E6%94%AF%E6%8C%81%E6%B7%B1%E5%B1%82%E5%B5%8C%E5%A5%97">相同点：不支持深层嵌套</a></li></ul></li><li><a href="#%E6%80%BB%E7%BB%93proxy%E5%92%8Cdefineproperty%E5%AF%B9%E6%AF%94">总结：proxy和defineProperty对比</a></li><li><a href="#%E5%A4%87%E6%B3%A8">备注：</a></li></ul></li></ul><h2 id="defineproperty和proxy的异同" tabindex="-1">defineProperty和proxy的异同 <a class="header-anchor" href="#defineproperty和proxy的异同" aria-hidden="true">#</a></h2><h3 id="区别一-监听方式" tabindex="-1">区别一：监听方式 <a class="header-anchor" href="#区别一-监听方式" aria-hidden="true">#</a></h3><p>  defineProperty 是<a href="/vue/reactive2.html">属性劫持</a></p><p>  proxy 是代理对象</p><h3 id="区别二-对象新增属性" tabindex="-1">区别二：对象新增属性 <a class="header-anchor" href="#区别二-对象新增属性" aria-hidden="true">#</a></h3><p>  defineProperty 无法监听对象新增属性</p><p>  proxy 可以</p><h3 id="区别三-对象删除属性" tabindex="-1">区别三：对象删除属性 <a class="header-anchor" href="#区别三-对象删除属性" aria-hidden="true">#</a></h3><p>  defineProperty 无法监听对象删除属性，proxy 可以</p><p>  proxy 有专门针对属性删除的方法 deleteProperty，可以在对象属性被删除时触发</p><h3 id="区别四-数组监听" tabindex="-1">区别四：数组监听 <a class="header-anchor" href="#区别四-数组监听" aria-hidden="true">#</a></h3><p>  defineProperty 不能监听数组（原来没有的）下标改变值的变化</p><p>   proxy 可以且不需要对数组的方法进行重载</p><h3 id="问题-数组的-push、pop、shift、unshift、splice、sort-reverse是无法触发-set-方法的" tabindex="-1">问题：数组的 push、pop、shift、unshift、splice、sort，reverse是无法触发 set 方法的？ <a class="header-anchor" href="#问题-数组的-push、pop、shift、unshift、splice、sort-reverse是无法触发-set-方法的" aria-hidden="true">#</a></h3><h3 id="解决方法-vue能对对数组的这些原生方法进行监听-是因为-vue-源码对数组的这些方法进行了重载" tabindex="-1">解决方法：Vue能对对数组的这些原生方法进行监听，是因为 Vue 源码对数组的这些方法进行了重载： <a class="header-anchor" href="#解决方法-vue能对对数组的这些原生方法进行监听-是因为-vue-源码对数组的这些方法进行了重载" aria-hidden="true">#</a></h3><p><code>代码示例：</code></p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">[</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">push</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">pop</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">shift</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">unshift</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">splice</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">sort</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">reverse</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">]</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">forEach</span><span style="color:#A6ACCD;">(</span><span style="color:#A6ACCD;font-style:italic;">method</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">original</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">Array</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span><span style="color:#F07178;">[</span><span style="color:#A6ACCD;">method</span><span style="color:#F07178;">]</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">defineProperty</span><span style="color:#F07178;">(</span><span style="color:#FFCB6B;">Array</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">method</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    value</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">original</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">apply</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">this,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">arguments</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div><h3 id="区别五-性能上" tabindex="-1">区别五：性能上 <a class="header-anchor" href="#区别五-性能上" aria-hidden="true">#</a></h3><p>  defineProperty 是循环遍历对象属性的方式来进行监听</p><p>  自然会比 proxy 对整个对象进行监听的方式要耗性能</p><h3 id="相同点-不支持深层嵌套" tabindex="-1">相同点：不支持深层嵌套 <a class="header-anchor" href="#相同点-不支持深层嵌套" aria-hidden="true">#</a></h3><h2 id="总结-proxy和defineproperty对比" tabindex="-1">总结：proxy和defineProperty对比 <a class="header-anchor" href="#总结-proxy和defineproperty对比" aria-hidden="true">#</a></h2><table><thead><tr><th style="text-align:center;">名称</th><th style="text-align:center;">set</th><th style="text-align:center;">get</th><th style="text-align:center;">add</th><th style="text-align:center;">delete</th><th style="text-align:center;">apply</th><th style="text-align:center;">性能</th></tr></thead><tbody><tr><td style="text-align:center;">defineProperty</td><td style="text-align:center;">是</td><td style="text-align:center;">是</td><td style="text-align:center;">否</td><td style="text-align:center;">否</td><td style="text-align:center;">否</td><td style="text-align:center;">快</td></tr><tr><td style="text-align:center;">proxy</td><td style="text-align:center;">是</td><td style="text-align:center;">是</td><td style="text-align:center;">是</td><td style="text-align:center;">是</td><td style="text-align:center;">是</td><td style="text-align:center;">慢</td></tr></tbody></table><h2 id="备注" tabindex="-1">备注： <a class="header-anchor" href="#备注" aria-hidden="true">#</a></h2><p>【1】proxy还能够检测到更多对象相关的操作，比如构造函数被调用</p><p>【2】在nodejs 高个版本下， 执行多次defineProperty 和proxy,proxy慢了30倍</p><p>【3】为了继续使用响应式，在vue2.x中额外增加和删除的属性需要使用 Vue.set(对象，添加的key,添加值)</p><p>【4】<strong>虽然单个API有性能差距，但是到Vue3中，可以利用Proxy带来的便利，在其他方面大幅提升性能</strong></p>`,31),p=[n];function r(o,i,c,y,d,h){return a(),s("div",null,p)}const A=e(l,[["render",r]]);export{F as __pageData,A as default};
